package gosrcfmt

import (
	"bytes"
	"fmt"
	"go/format"
	"go/parser"
	"go/scanner"
	"go/token"
	"io"
	"io/ioutil"
	"os"
	"strconv"
	"strings"

	"github.com/sirkon/message"
)

const (
	header = `// Code generated by %s. DO NOT EDIT.`
)

// Format formats data from src as a go code with gofmt utility
func Format(dest io.Writer, data []byte) {
	var buf bytes.Buffer
	buf.WriteString(fmt.Sprintf(header, strings.Join(os.Args, " ")))
	buf.WriteString("\n\n")
	buf.Write(data)

	var fset token.FileSet
	ast, err := parser.ParseFile(&fset, "", buf.Bytes(), parser.AllErrors|parser.ParseComments)

	if err != nil {
		switch v := err.(type) {
		case scanner.ErrorList:
			for _, e := range v {
				message.Error(e)
			}
		default:
			message.Error(err)
		}
		lines := strings.Split(buf.String(), "\n")
		lineCountLen := strconv.Itoa(len(lines))
		fr := fmt.Sprintf("%% %ds: %%s", len(lineCountLen))
		for i, line := range lines {
			message.Infof(fr, strconv.Itoa(i+1), line)
		}
		os.Exit(-1)
	}

	if err := format.Node(dest, &fset, ast); err != nil {
		message.Fatal(err)
	}
}

// FormatReader formats data from src as a go code with gofmt utility
func FormatReader(dest io.Writer, src io.Reader) {
	data, err := ioutil.ReadAll(src)
	if err != nil {
		panic(err)
	}
	Format(dest, data)
}
